import{c as P}from"./index-76afb0b9.js";import{r as y,g as H,a as w}from"./vendor-729d4b68.js";const St=P("ArrowLeft",[["path",{d:"m12 19-7-7 7-7",key:"1l729n"}],["path",{d:"M19 12H5",key:"x3x0zl"}]]),ft=P("Minus",[["path",{d:"M5 12h14",key:"1ays0h"}]]),At=P("Plus",[["path",{d:"M5 12h14",key:"1ays0h"}],["path",{d:"M12 5v14",key:"s699le"}]]),R=t=>{let o;const n=new Set,a=(I,S)=>{const T=typeof I=="function"?I(o):I;if(!Object.is(T,o)){const d=o;o=S??(typeof T!="object"||T===null)?T:Object.assign({},o,T),n.forEach(f=>f(o,d))}},r=()=>o,c={setState:a,getState:r,getInitialState:()=>s,subscribe:I=>(n.add(I),()=>n.delete(I)),destroy:()=>{n.clear()}},s=o=t(a,r,c);return c},B=t=>t?R(t):R;var O={exports:{}},N={},g={exports:{}},D={};/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var p=y;function G(t,o){return t===o&&(t!==0||1/t===1/o)||t!==t&&o!==o}var x=typeof Object.is=="function"?Object.is:G,F=p.useState,K=p.useEffect,Y=p.useLayoutEffect,k=p.useDebugValue;function X(t,o){var n=o(),a=F({inst:{value:n,getSnapshot:o}}),r=a[0].inst,e=a[1];return Y(function(){r.value=n,r.getSnapshot=o,V(r)&&e({inst:r})},[t,n,o]),K(function(){return V(r)&&e({inst:r}),t(function(){V(r)&&e({inst:r})})},[t]),k(n),n}function V(t){var o=t.getSnapshot;t=t.value;try{var n=o();return!x(t,n)}catch{return!0}}function W(t,o){return o()}var z=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?W:X;D.useSyncExternalStore=p.useSyncExternalStore!==void 0?p.useSyncExternalStore:z;g.exports=D;var j=g.exports;/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var h=y,q=j;function $(t,o){return t===o&&(t!==0||1/t===1/o)||t!==t&&o!==o}var J=typeof Object.is=="function"?Object.is:$,Q=q.useSyncExternalStore,Z=h.useRef,tt=h.useEffect,et=h.useMemo,rt=h.useDebugValue;N.useSyncExternalStoreWithSelector=function(t,o,n,a,r){var e=Z(null);if(e.current===null){var i={hasValue:!1,value:null};e.current=i}else i=e.current;e=et(function(){function c(d){if(!s){if(s=!0,I=d,d=a(d),r!==void 0&&i.hasValue){var f=i.value;if(r(f,d))return S=f}return S=d}if(f=S,J(I,d))return f;var _=a(d);return r!==void 0&&r(f,_)?(I=d,f):(I=d,S=_)}var s=!1,I,S,T=n===void 0?null:n;return[function(){return c(o())},T===null?void 0:function(){return c(T())}]},[o,n,a,r]);var l=Q(t,e[0],e[1]);return tt(function(){i.hasValue=!0,i.value=l},[l]),rt(l),l};O.exports=N;var ot=O.exports;const nt=H(ot),{useDebugValue:at}=w,{useSyncExternalStoreWithSelector:st}=nt;const it=t=>t;function ct(t,o=it,n){const a=st(t.subscribe,t.getState,t.getServerState||t.getInitialState,o,n);return at(a),a}const C=t=>{const o=typeof t=="function"?B(t):t,n=(a,r)=>ct(o,a,r);return Object.assign(n,o),n},L=t=>t?C(t):C;function M(t,o){let n;try{n=t()}catch{return}return{getItem:r=>{var e;const i=c=>c===null?null:JSON.parse(c,o==null?void 0:o.reviver),l=(e=n.getItem(r))!=null?e:null;return l instanceof Promise?l.then(i):i(l)},setItem:(r,e)=>n.setItem(r,JSON.stringify(e,o==null?void 0:o.replacer)),removeItem:r=>n.removeItem(r)}}const v=t=>o=>{try{const n=t(o);return n instanceof Promise?n:{then(a){return v(a)(n)},catch(a){return this}}}catch(n){return{then(a){return this},catch(a){return v(a)(n)}}}},ut=(t,o)=>(n,a,r)=>{let e={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:E=>E,version:0,merge:(E,A)=>({...A,...E}),...o},i=!1;const l=new Set,c=new Set;let s;try{s=e.getStorage()}catch{}if(!s)return t((...E)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),n(...E)},a,r);const I=v(e.serialize),S=()=>{const E=e.partialize({...a()});let A;const u=I({state:E,version:e.version}).then(m=>s.setItem(e.name,m)).catch(m=>{A=m});if(A)throw A;return u},T=r.setState;r.setState=(E,A)=>{T(E,A),S()};const d=t((...E)=>{n(...E),S()},a,r);let f;const _=()=>{var E;if(!s)return;i=!1,l.forEach(u=>u(a()));const A=((E=e.onRehydrateStorage)==null?void 0:E.call(e,a()))||void 0;return v(s.getItem.bind(s))(e.name).then(u=>{if(u)return e.deserialize(u)}).then(u=>{if(u)if(typeof u.version=="number"&&u.version!==e.version){if(e.migrate)return e.migrate(u.state,u.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return u.state}).then(u=>{var m;return f=e.merge(u,(m=a())!=null?m:d),n(f,!0),S()}).then(()=>{A==null||A(f,void 0),i=!0,c.forEach(u=>u(f))}).catch(u=>{A==null||A(void 0,u)})};return r.persist={setOptions:E=>{e={...e,...E},E.getStorage&&(s=E.getStorage())},clearStorage:()=>{s==null||s.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>_(),hasHydrated:()=>i,onHydrate:E=>(l.add(E),()=>{l.delete(E)}),onFinishHydration:E=>(c.add(E),()=>{c.delete(E)})},_(),f||d},Et=(t,o)=>(n,a,r)=>{let e={storage:M(()=>localStorage),partialize:_=>_,version:0,merge:(_,E)=>({...E,..._}),...o},i=!1;const l=new Set,c=new Set;let s=e.storage;if(!s)return t((..._)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),n(..._)},a,r);const I=()=>{const _=e.partialize({...a()});return s.setItem(e.name,{state:_,version:e.version})},S=r.setState;r.setState=(_,E)=>{S(_,E),I()};const T=t((..._)=>{n(..._),I()},a,r);r.getInitialState=()=>T;let d;const f=()=>{var _,E;if(!s)return;i=!1,l.forEach(u=>{var m;return u((m=a())!=null?m:T)});const A=((E=e.onRehydrateStorage)==null?void 0:E.call(e,(_=a())!=null?_:T))||void 0;return v(s.getItem.bind(s))(e.name).then(u=>{if(u)if(typeof u.version=="number"&&u.version!==e.version){if(e.migrate)return[!0,e.migrate(u.state,u.version)];console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,u.state];return[!1,void 0]}).then(u=>{var m;const[b,U]=u;if(d=e.merge(U,(m=a())!=null?m:T),n(d,!0),b)return I()}).then(()=>{A==null||A(d,void 0),d=a(),i=!0,c.forEach(u=>u(d))}).catch(u=>{A==null||A(void 0,u)})};return r.persist={setOptions:_=>{e={...e,..._},_.storage&&(s=_.storage)},clearStorage:()=>{s==null||s.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>f(),hasHydrated:()=>i,onHydrate:_=>(l.add(_),()=>{l.delete(_)}),onFinishHydration:_=>(c.add(_),()=>{c.delete(_)})},e.skipHydration||f(),d||T},lt=(t,o)=>"getStorage"in o||"serialize"in o||"deserialize"in o?ut(t,o):Et(t,o),_t=lt,It=(()=>{try{const t="__localStorage_test__";return localStorage.setItem(t,t),localStorage.removeItem(t),!0}catch{return!1}})(),mt=L()(_t((t,o)=>({cart:{items:[],total:0,itemCount:0},addToCart:(n,a=1)=>{t(r=>{const e=r.cart.items.find(s=>s.id===n.id);let i;if(e)i=r.cart.items.map(s=>s.id===n.id?{...s,quantity:s.quantity+a}:s);else{const s={id:n.id,product:n,quantity:a};i=[...r.cart.items,s]}const l=i.reduce((s,I)=>s+I.product.price*I.quantity,0),c=i.reduce((s,I)=>s+I.quantity,0);return{cart:{items:i,total:l,itemCount:c}}})},removeFromCart:n=>{t(a=>{const r=a.cart.items.filter(l=>l.id!==n),e=r.reduce((l,c)=>l+c.product.price*c.quantity,0),i=r.reduce((l,c)=>l+c.quantity,0);return{cart:{items:r,total:e,itemCount:i}}})},updateCartQuantity:(n,a)=>{t(r=>{if(a<=0){const c=r.cart.items.filter(S=>S.id!==n),s=c.reduce((S,T)=>S+T.product.price*T.quantity,0),I=c.reduce((S,T)=>S+T.quantity,0);return{cart:{items:c,total:s,itemCount:I}}}const e=r.cart.items.map(c=>c.id===n?{...c,quantity:a}:c),i=e.reduce((c,s)=>c+s.product.price*s.quantity,0),l=e.reduce((c,s)=>c+s.quantity,0);return{cart:{items:e,total:i,itemCount:l}}})},clearCart:()=>{t({cart:{items:[],total:0,itemCount:0}})},getCartTotal:()=>o().cart.total,getCartItemCount:()=>o().cart.itemCount}),{name:"vaporlax-cart",storage:M(()=>It?localStorage:{getItem:()=>null,setItem:()=>{},removeItem:()=>{}}),partialize:t=>({cart:t.cart}),onRehydrateStorage:()=>t=>{if(t){const o=t.cart.items.reduce((a,r)=>a+r.product.price*r.quantity,0),n=t.cart.items.reduce((a,r)=>a+r.quantity,0);t.cart.total=o,t.cart.itemCount=n}}})),pt=L(t=>({isCartDrawerOpen:!1,isMobileMenuOpen:!1,isLoading:!1,setCartDrawerOpen:o=>{t({isCartDrawerOpen:o})},setMobileMenuOpen:o=>{t({isMobileMenuOpen:o})},setLoading:o=>{t({isLoading:o})}}));L((t,o)=>({products:[],filteredProducts:[],filters:{},setProducts:n=>{t({products:n,filteredProducts:n})},setFilters:n=>{t(a=>{const r={...a.filters,...n};let e=[...a.products];if(r.category&&(e=e.filter(i=>i.category.toLowerCase()===r.category.toLowerCase())),r.priceRange&&(e=e.filter(i=>i.price>=r.priceRange.min&&i.price<=r.priceRange.max)),r.inStock!==void 0&&(e=e.filter(i=>i.inStock===r.inStock)),r.featured!==void 0&&(e=e.filter(i=>i.featured===r.featured)),r.search){const i=r.search.toLowerCase();e=e.filter(l=>l.name.toLowerCase().includes(i)||l.description.toLowerCase().includes(i)||l.category.toLowerCase().includes(i))}return{filters:r,filteredProducts:e}})},clearFilters:()=>{t(n=>({filters:{},filteredProducts:n.products}))},getProductById:n=>o().products.find(r=>r.id===n)}));export{St as A,ft as M,At as P,pt as a,mt as u};
//# sourceMappingURL=store-2a85050e.js.map
